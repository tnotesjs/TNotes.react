# [0068. React 设计理念](https://github.com/tnotesjs/TNotes.react/tree/main/notes/0068.%20React%20%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5)

<!-- region:toc -->

- [1. 🎯 本节内容](#1--本节内容)
- [2. 🫧 评价](#2--评价)
- [3. 🤔 如何理解“设计理念”？](#3--如何理解设计理念)
- [4. 🤔 为什么 React 是“声明式”的，而不是“命令式”的？](#4--为什么-react-是声明式的而不是命令式的)
- [5. 🤔 为什么 React 要“组件化”？](#5--为什么-react-要组件化)
- [6. 🤔 为什么 React 要坚持“单向数据流”？](#6--为什么-react-要坚持单向数据流)
- [7. 🤔 为什么说“UI 是状态的函数”？](#7--为什么说ui-是状态的函数)
- [8. 🤔 为什么 React 要强调“纯函数”？](#8--为什么-react-要强调纯函数)
- [9. 🤔 为什么 React 需要“虚拟 DOM”？](#9--为什么-react-需要虚拟-dom)
- [10. 🤔 React 的设计哲学可以用一句话总结吗？](#10--react-的设计哲学可以用一句话总结吗)
- [11. 🤔 我该如何实践这些理念？](#11--我该如何实践这些理念)
- [12. 一、声明式（Declarative）：描述“是什么”，而不是“怎么做”](#12-一声明式declarative描述是什么而不是怎么做)
- [13. 二、组件化（Component-Based）：像搭积木一样构建 UI](#13-二组件化component-based像搭积木一样构建-ui)
- [14. 三、单向数据流（Unidirectional Data Flow）：数据从上往下流](#14-三单向数据流unidirectional-data-flow数据从上往下流)
- [15. 四、状态驱动 UI（State-Driven UI）：数据变，界面自动变](#15-四状态驱动-uistate-driven-ui数据变界面自动变)
- [16. 五、纯函数与可预测性（Purity & Predictability）](#16-五纯函数与可预测性purity--predictability)
- [17. 六、虚拟 DOM：高效更新的“幕后英雄”](#17-六虚拟-dom高效更新的幕后英雄)
- [18. 总结：React 的设计哲学一句话](#18-总结react-的设计哲学一句话)

<!-- endregion:toc -->

## 1. 🎯 本节内容

## 2. 🫧 评价

- React 的设计理念：为什么它这样工作？
  - 如果你刚刚开始学习 React，可能会对一些概念感到困惑：为什么要在 JavaScript 里写 HTML（JSX）？为什么状态变了界面就自动更新？为什么组件要“纯”？别担心——这些设计都不是随意决定的，而是源于 React 背后清晰而强大的设计理念。
  - 理解这些理念，不仅能帮你写出更好的代码，还能让你真正“懂” React，而不是机械地复制粘贴。本文专为 React 初学者编写，用简单易懂的方式，带你走进 React 的设计哲学。
- 当你写 React 时，不妨问自己：
  1. 我是在描述 UI 的目标状态，还是在命令 DOM？（声明式）
  2. 这个界面能否拆成更小的组件？（组件化）
  3. 数据是不是只从父组件往下传？（单向数据流）
  4. UI 是否只是状态的映射？（状态驱动）
  5. 我的组件有没有副作用？（纯函数）
  - 当这些问题都能被你清晰回答时，你就真正理解了 React 为什么“这样工作”。

## 3. 🤔 如何理解“设计理念”？

- 这里提到的“设计理念”，主要是指 React 项目遵循的一些原则。
- 这些原则，在 React 项目迭代的过程中，始终遵循，而且几乎没有变过。
- 本节介绍的设计理念，就是上面提到的这些 React 始终遵循的一些原则，重点在于理解为什么 React 要这么做，好处是什么？

## 4. 🤔 为什么 React 是“声明式”的，而不是“命令式”的？

先说结论：

- 命令式虽然在理想情况下具备最优的性能，但是对开发不友好。
- 声明式更简单，更易读，更易维护，对开发更友好。

React 选择“声明式”并不是因为“命令式不好”，而是因为 React 想让开发者站在更高层的抽象层上思考问题。底层依旧是命令式执行，只是你不再需要关心细节。

---

想象你要让一个灯泡亮起来：

- 命令式方式（传统写法）： “找到灯泡 → 检查是否通电 → 如果没亮就打开开关 ……” 这种方式关注每一步操作，容易出错且难以维护。
- 声明式方式（React 的写法）： “灯泡应该是亮的。” 你只描述最终状态，React 会自动处理“怎么实现”。

在 React 中，组件就是对 UI 的声明：

```jsx
function Greeting({ isLoggedIn }) {
  return isLoggedIn ? <h1>欢迎回来！</h1> : <h1>请登录</h1>
}
```

你不需要写 `document.getElementById()` 去改 DOM，只要告诉 React “如果用户登录了就显示 A，否则显示 B”，React 会帮你完成更新。

显然，声明式让流程更简洁、逻辑更清晰、更易调试。

但是，命令式的流程依旧是不可或缺的，就好比 React 是你的助手，你只需要描述“灯泡应该是亮的”，你的助手 React 会自动去完成命令式的流程。

- 声明式：流程更简洁、逻辑更清晰、更易调试（对开发更友好）
- 命令式：流程最直接高效（理想情况下）

设想理想情况：让灯泡亮起来，命令式执行至少需要 3 个原子操作。这 3 步已经是任务在命令层面上的最小可分解单元，也就是命令式的理论最优路径。

现在思考一个问题：声明式的 React 程序有可能在 3 步内完成该任务吗？

答案是不可能！

React “助手” 干的活儿永远 ≥ 3 步。助手在完成你的任务时，还会做一些额外的工作，最终步骤始终会大于等于 3 步 => “……（额外工作） -> 找到灯泡 -> ……（额外工作） → 检查是否通电 -> ……（额外工作） → 如果没亮就打开开关 ……”，这些多出的额外工作又是每个当前的 React 版本自以为必要的，不能跳过。随着 React 的不断迭代，React 性能会变得越来越好，这个性能变好的过程，本质就是优化额外工作的过程，推翻之前自以为必要的额外工作，用更好的方案去替代，让步骤数尽可能接近最优解 3。

## 5. 🤔 为什么 React 要“组件化”？

React 认为复杂界面可以拆成独立、可复用的小单元——组件。

比如电商页面可以拆成：

- `<Header />`
- `<ProductList />`
- `<ShoppingCart />`
- `<Footer />`

组件之间通过 props 传递数据：

```jsx
function App() {
  return (
    <div>
      <Header title="我的商店" />
      <ProductList products={products} />
    </div>
  )
}
```

组件化的好处：

- 复用性：同一个 `<Button>` 能在多处使用；
- 协作性：多人可同时开发不同组件；
- 可测试性：组件可单独测试。

✅ 核心理念：UI = 组件的组合。

---

## 6. 🤔 为什么 React 要坚持“单向数据流”？

React 的数据流是从上往下的（父组件 → 子组件），通过 props 传递。

```jsx
function App() {
  const user = { name: '小明' }
  return <Profile user={user} />
}

function Profile({ user }) {
  return <h2>你好，{user.name}！</h2>
}
```

子组件不能直接修改 props。如果想改变数据，只能通过回调函数让父组件去更新状态，再重新传入。

这种单向流动带来两大优势：

1. 可预测性：数据流向清晰，便于调试；
2. 稳定性：防止组件间相互干扰。

💡 类比：父母给孩子零花钱（props），孩子不能自己印钱，只能请求父母更新。

---

## 7. 🤔 为什么说“UI 是状态的函数”？

React 的核心理念是：

> UI = f(state) 用户界面由状态驱动。

状态（state）变，UI 就会自动重新渲染。例如：

```jsx
function Counter() {
  const [count, setCount] = useState(0)
  return (
    <div>
      <p>你点击了 {count} 次</p>
      <button onClick={() => setCount(count + 1)}>+1</button>
    </div>
  )
}
```

你不需要自己更新 DOM，React 会根据最新的 `count` 自动渲染新 UI。

✅ 好处：开发者只需关心“状态是什么”，不必操心“DOM 怎么变”。

---

## 8. 🤔 为什么 React 要强调“纯函数”？

React 鼓励组件是纯函数：

> 相同的输入（props + state） ➜ 必然得到相同的输出（UI）

纯函数没有副作用，不修改外部变量，不发送请求、不操作 DOM。

```jsx
// ✅ 推荐写法
function Welcome({ name }) {
  return <h1>你好，{name}！</h1>
}

// ❌ 不推荐
function BadComponent() {
  console.log('渲染时执行副作用！') // 产生副作用
  return <div>...</div>
}
```

为什么这样设计？

- 渲染可预测，便于调试；
- React 可安全地多次调用组件（如并发模式）；
- 测试简单（输入确定，输出固定）。

⚠️ 副作用（如请求/事件监听）应放在 `useEffect` 中，而非组件函数体内。

---

## 9. 🤔 为什么 React 需要“虚拟 DOM”？

虽然开发者不再直接操作 DOM，但 React 内部必须高效地“更新”它。

React 的解决方案是 虚拟 DOM（Virtual DOM）：

1. React 在内存中维护一个虚拟的 UI 树；
2. 当状态变化时，生成新的虚拟树；
3. React 比较新旧树的差异（Diffing）；
4. 只把有变化的部分更新到真实 DOM。

✅ 这样既保证性能，又保持声明式开发体验。

换句话说，虚拟 DOM 是 React 的幕后英雄，让“写起来简单、跑得也快”成为可能。

---

## 10. 🤔 React 的设计哲学可以用一句话总结吗？

可以：

> “用声明式、组件化的方式，通过状态驱动 UI，实现可预测、可维护、高性能的用户界面。”

React 不是一堆规则，而是一套思考方式，帮助你更轻松地构建复杂 UI。

---

## 11. 🤔 我该如何实践这些理念？

建议：

1. 写一个简单的 Todo List 来练习这些概念；
2. 阅读 React 官方文档的 [核心概念](https://zh-hans.react.dev/learn)；
3. 不怕出错——每个 React 开发者都从“为什么界面不更新？”开始。

## 12. 一、声明式（Declarative）：描述“是什么”，而不是“怎么做”

想象你要让一个灯泡亮起来。

- 命令式写法（传统方式）：  
  “先找到灯泡 → 检查是否通电 → 如果没亮就打开开关 → 等待 0.1 秒确认是否亮了……”  
  这种方式关注每一步操作，容易出错且难以维护。

- 声明式写法（React 的方式）：  
  “灯泡应该是亮的。”  
  你只描述最终状态，React 会自动处理如何从当前状态变成目标状态。

在 React 中，你写的组件就是对 UI 的声明。比如：

```jsx
function Greeting({ isLoggedIn }) {
  return isLoggedIn ? <h1>欢迎回来！</h1> : <h1>请登录</h1>
}
```

你不需要手动操作 DOM（比如 `document.getElementById().innerHTML = ...`），只需要告诉 React：“如果用户已登录，就显示‘欢迎回来’；否则显示‘请登录’”。React 会自动帮你更新界面。

✅ 好处：代码更简洁、逻辑更清晰、更容易推理和调试。

---

## 13. 二、组件化（Component-Based）：像搭积木一样构建 UI

React 认为，复杂的用户界面可以拆分成一个个独立、可复用的小部件，这就是“组件”。

比如一个电商页面可以拆成：

- `<Header />`
- `<ProductList />`
- `<ShoppingCart />`
- `<Footer />`

每个组件管理自己的内容、样式和行为，彼此之间通过“属性（props）”传递数据。

```jsx
function App() {
  return (
    <div>
      <Header title="我的商店" />
      <ProductList products={products} />
    </div>
  )
}
```

这种设计让你：

- 复用代码：同一个 `<Button>` 组件可以用在页面任何地方。
- 分工协作：不同开发者可以同时开发不同组件。
- 易于测试：每个组件都可以单独测试，不依赖整个应用。

✅ 核心思想：UI = 组件的组合。

---

## 14. 三、单向数据流（Unidirectional Data Flow）：数据从上往下流

在 React 中，数据的流动方向是单向的：从父组件 → 子组件，通过 props 传递。

```jsx
// 父组件
function App() {
  const user = { name: '小明' }
  return <Profile user={user} />
}

// 子组件
function Profile({ user }) {
  return <h2>你好，{user.name}！</h2>
}
```

子组件不能直接修改传入的 props（React 会报错）。如果子组件需要改变数据，必须通过回调函数通知父组件，由父组件更新状态后再重新传递下来。

这种设计带来两大好处：

1. 可预测性：你知道数据从哪里来、到哪里去，调试时更容易追踪问题。
2. 避免副作用：防止组件之间互相干扰，让应用更稳定。

> 💡 小贴士：这就像父母给孩子零花钱（props），孩子不能自己印钱，但可以告诉父母“我需要更多”，由父母决定是否给。

---

## 15. 四、状态驱动 UI（State-Driven UI）：数据变，界面自动变

React 的核心原则之一是：UI 是状态（state）的函数。

也就是说，只要状态变了，UI 就会自动重新渲染，保持同步。

```jsx
function Counter() {
  const [count, setCount] = useState(0)

  return (
    <div>
      <p>你点击了 {count} 次</p>
      <button onClick={() => setCount(count + 1)}>+1</button>
    </div>
  )
}
```

你不需要手动更新 `<p>` 标签的内容。只要调用 `setCount` 改变状态，React 就会自动重新运行 `Counter` 函数，生成新的 UI。

✅ 优势：开发者只需关注“状态是什么”，不用操心“怎么更新 DOM”。

---

## 16. 五、纯函数与可预测性（Purity & Predictability）

React 鼓励组件是“纯函数”——即：相同的输入（props + state），总是返回相同的 UI 输出，且不产生副作用（如直接修改全局变量、发送网络请求等）。

```jsx
// ✅ 纯函数组件（推荐）
function Welcome({ name }) {
  return <h1>你好，{name}！</h1>
}

// ❌ 非纯函数（不推荐在 render 中做）
function BadComponent() {
  console.log('每次渲染都打印！') // 副作用
  return <div>...</div>
}
```

纯函数的好处：

- 容易测试（输入 A，输出一定是 B）
- React 可以安全地多次调用组件（比如在并发渲染时）
- 减少 bug，提升可维护性

> ⚠️ 注意：副作用（如数据请求、订阅事件）应放在 `useEffect` 中，而不是组件主体里。

---

## 17. 六、虚拟 DOM：高效更新的“幕后英雄”

虽然你不需要天天操作 DOM，但了解 React 如何高效更新界面很有帮助。

React 在内存中维护一个 虚拟 DOM（Virtual DOM） ——它是真实 DOM 的轻量副本。当状态变化时：

1. React 生成新的虚拟 DOM；
2. 与旧的虚拟 DOM 对比，找出最小差异（这个过程叫 Diffing）；
3. 只把真正需要更新的部分应用到真实 DOM 上。

这样避免了频繁、低效的 DOM 操作，让应用更流畅。

✅ 对开发者来说：你只需关心状态和 UI，性能优化交给 React。

---

## 18. 总结：React 的设计哲学一句话

> “用声明式、组件化的方式，通过状态驱动 UI，实现可预测、可维护、高性能的用户界面。”

作为初学者，你不需要一开始就掌握所有细节。但记住这些核心理念，会在你遇到困惑时指明方向：

- 写组件时，问自己：“这个 UI 应该长什么样？”（声明式）
- 遇到复杂界面，试着拆成小组件（组件化）
- 数据从哪来？只能从父组件通过 props 传入（单向数据流）
- 界面不更新？检查状态是否真的变了（状态驱动）
- 避免在组件里做“偷偷摸摸”的事（保持纯函数）

当你理解了“为什么 React 这样设计”，你会发现：它不是一堆规则，而是一套帮助你更轻松、更可靠地构建用户界面的思维方式。

---

下一步建议：

- 动手写一个简单的 Todo List 应用，实践这些理念
- 阅读 React 官方文档的 [“核心概念”](https://zh-hans.react.dev/learn) 章节
- 不要怕犯错——每个 React 开发者都是从“为什么界面不更新？”开始的 😊
